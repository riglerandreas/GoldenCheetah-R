---
title: "Feature Pipeline"
author: "ari"
date: '2023-01-09'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Description
Goal:
Create Features for a ML model, to predict the ftp based on the actual training data (history)

Input:
- ftp/laktat data (for the season dates and to calculate the right intensity and etc.)
- weeks/season
- gc activities aggregated/activity
- Interval aggregations

Output:
Aggregation of every season as a feature

## Parameters
```{r}
library(tidyverse)

source("functions_ftp_laktat.R")
source("functions_import.R")
source("functions_sesons.R")
source("functions_intervall.R")
```

```{r}
weeks_per_season = 12


intensity_min <- 0.88 #minimum intensity to count as an Interval intensity = watt_interval_mean/watt_ftp
device_list = c("BAsso_Vector", "P2M", "P2Cros", "P2MIndoor") # List of trust able devices for interval aggregation

path_ftp_tests <- "C:/Users/rigle/Documents/Training/Laktat FTP/laktat_watt_ftp.csv"
path_intervalls <- "Results/intervall_aggregation.csv"
path_activities <- "Results/goldencheetah_tss.csv"
path_activities_raw <- "C:/Users/rigle/AppData/Local/GoldenCheetah/Andl/activities/"   
```

## FTP / Laktat Data
```{r}

laktat_results<- read_csv2(path_ftp_tests) %>% mutate(date = as.Date(date, format = "%d.%m.%Y"))
```

### ftp values
```{r}
ftp_values <- add_missing_dates(laktat_results,colname="w_5mmol")

ftp_values%>%
  ggplot(aes(x=date, y = w_5mmol))+
  geom_line()
```


### Calculate the FTP from the Lactat

Analyse_seasons_v1.Rmd

## Activity data

```{r}
data_gc <-  read_csv(path_activities)

data_gc <- prepare_gc_summary(data_gc)
```


## Intervals

### update intervals

```{r}
update_intervals <-function(path_activities_gc, path_intervalls){
  library("jsonlite")
  
  result_old <- read_csv2(path_intervalls)
  max_date <- result_old %>% summarise(max(date)) %>% pull() + 1 
  
  print(str_c("last processed: ", max_date))
  
  #get all new files
  files_sel <- choose_files(path_activities_gc, max_date,Sys.Date())
  
  result_list <- list()
    for (i in seq_along(files_sel$file_name)) {
      
      file_sel <- files_sel[i,]
      result_list[[i]] <- read_intervals(path_activities_gc, file_sel)
    }
  result <- bind_rows(result_list)

  result_new <- result_old %>% bind_rows(result) %>% arrange(desc(date))
  result_new %>% write_csv2(path_intervalls)  
  
  return(result_new)
}




```

```{r}
data_intervals_raw <- update_intervals(path_activities_raw, path_intervalls)


```



### process intervalls


```{r}

data_intervals <- extract_intervals(data_intervals_raw, device_list, ftp_values)

data_intervals %>% group_by(date) %>% summarise(min = sum(min)) %>%
  ggplot(aes(x=date, y = min)) + 
  geom_point() +
  theme_light()
```


## Join and aggregate

```{r}
seasons_laktat_watt <- laktat_results 

data_season <- generate_season_summary(lactat_data = laktat_results, data_gc = data_gc, weeks_per_season)

data_season %>% arrange(date_test) %>% select(year, date_test, everything())
```

## Hier weitermachen
Bei dieser Funktion passt etwas nicht

```{r}
generate_season_summary_2 <- function(lactat_data, data_gc, data_intervals_all, duration_weeks){
  # aggregates the aktivity data per season
  #
  # lactat_data ... tibble with date and watt_2mmol, watt_5mmol values for each season
  # data_gc ... activity data from gc 
  # duration_weeks ... how many weeks are considered per season?
  #
  # the date of today is also included as a season
  
  #----------- create season dates
  library(lubridate)
  today_date = tibble(date = today())
  
  lactat_calculated <- lactat_data  %>% bind_rows(today_date) %>% 
    mutate(date_start = date - weeks(duration_weeks)) 
  
  #--------------
  activites_aggregated_list <- list()
  for (i in seq_along(lactat_calculated$date)) {
    date_start = lactat_calculated$date_start[i]
    date_end = lactat_calculated$date[i]
    
    watt_2mmol <- lactat_calculated$w_2mmol[i]
    watt_5mmol <- lactat_calculated$w_5mmol[i]
    
    #---------- create dates of season for filtering
    dates = tibble(date = seq(ymd(date_start), ymd(date_end), by = "1 day"))

        date_char <- function(df){
          #joining with characters is safer
              df %>% mutate(date = as.character(date))
        }
        
    activities_data <- date_char(dates) %>% left_join(date_char(data_gc), by = "date") %>%
                              filter(duration > 0) %>%
                       mutate(date = as.Date(date))

    data_intervals <-  date_char(dates) %>% 
                            left_join(date_char(data_intervals_raw), by = "date") %>% filter(!is.na(watt)) %>% 
                       mutate(date = as.Date(date))
    
  #---------------  aggregation -------------
    aggregation_1 <- activities_data %>% 
                            mutate(long = case_when(duration >= 3 ~ 1, TRUE ~ 0),
                                   high_TSS = case_when(TSS > 100 ~1, TRUE ~ 0)) %>%
                            
                            summarise(n = n(),
                                      n_long = sum(long, na.rm = TRUE),
                                      n_high_TSS = sum(high_TSS, na.rm = TRUE),
                                      TSS = sum(TSS, na.rm = TRUE),
                                      duration = sum(duration, na.rm = TRUE)) %>%
                            mutate(date_test = date_end,
                                   watt_2mmol = !!watt_2mmol,
                                   watt_5mmol = !!watt_5mmol)
    
    aggregation_watt <- activities_data %>% filter(w_mean>0) %>%
                              summarise(n_bike = n(),
                                        watt = mean(w_mean, na.rm = TRUE))
    aggregation_intervals <- data_intervals %>% #filter(intensity > intensity_min) %>%
                              summarise(n_interval = n(),
                                        interval_watt = mean(watt, na.rm = TRUE),
                                        interval_hr = mean(hr, na.rm = TRUE),
                                        interval_min = sum(min, na.rm = TRUE))
    
    activites_aggregated_list[[i]]  <- aggregation_1 %>% bind_cols(aggregation_watt) %>% bind_cols(aggregation_intervals)
  }
  
  result= bind_rows(activites_aggregated_list) %>% 
    distinct(date_test, .keep_all = TRUE) %>%
    mutate(year = lubridate::year(date_test) %>% as.factor())
  
  return(result)
}


test <- generate_season_summary_2(lactat_data = laktat_results, 
                                  data_gc = data_gc, 
                                  data_intervals = data_intervals,
                                  weeks_per_season)
test

date_char(dates) %>% 
                            left_join(date_char(data_intervals), by = "date") %>% #filter(watt >0) %>% 
                       mutate(date = as.Date(date)) %>% filter(!is.na(watt))
```

```{r}
sel_years <-c(2017,2021,2022)

intensity_min <- 0.88 

235*intensity_min

watt_device(data_intervals,device_list ) %>% filter(watt_device == TRUE)%>% 
        left_join(ftp_values, by = "date") %>%
  mutate(intensity = watt / w_5mmol) %>%
  filter(intensity > intensity_min)
```


```{r}
plot_interval_data <- watt_device(data_intervals,device_list ) %>% filter(watt_device == TRUE)%>% 
                    mutate(year = lubridate::year(date),
                           watt_secs = watt*secs) %>%
                    #filter(year %in% sel_years) %>% 
        left_join(ftp_values, by = "date") %>%
  mutate(intensity = watt / w_5mmol) %>%
  filter(intensity > intensity_min) 

plot_interval_data %>%
  #summarise(max(date))
  ggplot(aes(x=date))+
  geom_point(aes(y=watt, color = intensity))
  
  

```